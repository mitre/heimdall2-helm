## Please see the following for explanations on many of the Heimdall specific envvars:
# https://github.com/mitre/heimdall2/wiki/Environment-Variables-Configuration
# apps/backend/.env-example

# classificationBannerText: default is no banner
# classificationBannerTextColor: default white
# classificationBannerColor: default red

nodeEnv: production

# adminEmail: default admin@heimdall.local
# adminUsesExternalAuth: default false
# adminPassword: default autogenerated (CHECK THE LOGS TO FIND IT)

# localLoginDisabled: default false
# registrationDisabled: default false
# oneSessionPerUser: default false
## Generate the following via `openssl rand -hex 64` and set
# jwtSecret: long-random-string-of-text
## Set `1d` or `25m`
# jwtExpireTime: 25m

## Generate the following via `openssl rand -hex 33` and set
# apiKeySecret: different-long-random-string-of-text
# maxFileUploadSize: size-in-megabytes (default 50)

## Set FDQN for external database host or set `posgresql.enabled` equal to `true`
#databaseHost: postgresql.example.com
## Set external database port or set `postgresql.enabled` equal to `true`
#databasePort: 5672
databaseName: heimdall-database
databaseUsername: postgres
## Set postgres user's password via `openssl rand -hex 33`
# databasePassword: long-random-string-of-text
# databaseSsl: default false
# databaseSslInsecure: default false
# databaseSslKey: path-or-raw-key
# databaseSslCert: path-or-raw-cert
# databaseSslCa: path-or-raw-ca

# externalUrl: 'public'/externally facing URL for your deployment (ex. for use in callback urls for auth integrations)

# splunkHostUrl: default empty string (ex. https://your.splunk.domain.com)
# tenableHostUrl: default empty string (ex. https://your.tenable.domain.com)

# ldapEnabled: default false
# ldapHost: url
# ldapPort: default 389
# ldapBindDn: Dn of user used for lookups
# ldapPassword: user's password
# ldapSearchBase: ex. "OU=Users, DC=<yourdomain>, DC=local"
# ldapSearchFilter: ex. "sAMAccountName={{username}}"
# ldapNameField: default name
# ldapMailField: default mail
# ldapSsl: default false
# ldapSslInsecure: default false
# ldapSslCa: path-or-raw-ca

# googleClientId: value-from-google
# googleClientSecret: value-from-google

# githubClientId: value-from-github
# githubClientSecret: value-from-github
# githubEnterpriseInstanceBaseUrl: default https://github.com/
# githubEnterpriseInstanceApiUrl: default https://api.github.com/

# gitlabClientId: value-from-gitlab
# gitlabClientSecret: value-from-gitlab
# gitlabBaseUrl: default https://gitlab.com/

# oktaDomain: yourdomain.okta.com
# oktaClientId: value-from-okta
# oktaClientSecret: value-from-okta

# oidcName: frontend-name
# oidcIssuer: base url, ex. https://sample.us.auth0.com
# oidcAuthorizationUrl: auth endpoint, ex. https://sample.us.autho0.com/authorize
# oidcTokenUrl: token endpoint, ex. https://sample.us.auth0.com/token
# oidcUserInfoUrl: info endpoint, ex. https://sample.us.autho0.com/userinfo
# oidcClientId: value-from-oidc
# oidcClientSecret: value-from-oidc
# oidcExternalGroups: default false

postgresql:
  enabled: true

  image:
    repository: postgres
    pullPolicy: Always
    tag: "13"

  persistence:
    ## Volume used to store the Heimdall's data. Default is boolean `false`.
    enabled: false
    size: "100Mi"
    ## Sets persistent volume claim's storageClassName. Defaults to `default`.
    storageClassName: "default"
    accessMode: "ReadWriteOnce"

  service:
    type: ClusterIP
    port: 5672

  podAnnotations: {}

  podSecurityContext: {}

  securityContext: {}

  resources: {}

  nodeSelector: {}

  tolerations: []

  affinity: {}

certs:
  name: heimdall-cacerts # name of the configmap that will include all the certs' file contents
  image: # which image with root/sufficient privileges will be used to take the injected certs and process them into the locations that the system will be looking for
    repository: registry.access.redhat.com/ubi8/ubi # the default Heimdall image is currently built on UBI 8
    pullPolicy: Always
    tag: "latest"
  command: "['sh', '-c', 'update-ca-trust']" # RHEL style distros use the `update-ca-trust` command to update the system CA trust store
  injectedCertsMountPath: /etc/pki/ca-trust/source/anchors # the location that `update-ca-trust` looks inside for user supplied certs
  processedCertsMountPaths: [/etc/pki/ca-trust/extracted/openssl, /etc/pki/ca-trust/extracted/pem, /etc/pki/ca-trust/extracted/java, /etc/pki/ca-trust/extracted/edk2] # due to the chart using `emptyDir` (which supplies a completely blank dir) to specify the shared volumes between this container and Heimdall's, and due to `update-ca-trust` apparently requiring several subdirectories underneath /etc/pki/ca-trust/extracted to exist, we need to manually specify each subdirectory
  securityContext: {}
  certificates:
    # - filename: name_of_cert.pem
    #   contents: |
    #     certificates file contents

heimdall:
  image:
    repository: mitre/heimdall2
    pullPolicy: Always
    tag: "release-latest"

  service:
    type: ClusterIP
    port: 3000

  ingress:
    enabled: true

    hosts:
      - host: localhost
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: heimdall
                port:
                  number: 3000

    # annotations:
    #   traefik.ingress.kubernetes.io/router.entrypoints: websecure
    #   traefik.ingress.kubernetes.io/router.tls: "true"
    #   traefik.ingress.kubernetes.io/service.sticky.cookie: "true"

    # className: ingress class name

    # tls:
    #   - name: nginx
    #     secretName: ingress-secret
    #     hosts:
    #       - heimdall.example.com

  podAnnotations: {}

  podSecurityContext: {}

  securityContext: {}

  resources: {}

  nodeSelector: {}

  tolerations: []

  affinity: {}

# imagePullSecrets:
#   - name: your-secret-name
